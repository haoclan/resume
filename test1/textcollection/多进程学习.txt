6-27日发现一堆问题。。。

lists:foreach(Fun,List)  的正确使用方式

以及 回忆加 写写多线程的东西
以及新的知识


问题2
奇怪的是，我代码中在spawn（) 需要函数的地方传入函数名才对  而不是模块：函数。因为模块已经有了！！
之前的filter 传入的是 fun 函数名/参数  函数说明中第一个参数是 predicate 是谓语 而不是Fun


对spawn的使用需要多多练习
也就是说 在函数体内部一般使用 spawn（fun()）一个参数的
在shell中一般使用(module，函数名，参数)？？？？？



并不是P3页码中 就是在函数中使用spawn(模块，函数，参数)
？？？？？？？？？？？？？？？？？？？？？？？？？？？？


问题1
如何获取到spawn 里面的spawn返回的信息（所以没法让最内层的那个进程崩溃）
子进程返回的Pid（不是2进制），不能再二次去使用吗？？？？？？？？？？？？？
<<>>        <>
想让函数返回创建的子进程的Pid 但是Pid又是没有绑定的。。


当然如果分开后就可以了. 因为可以拿到Pid了（start_1）（spawn_monitor是用当前进程生成并监听）
1创建一个子进程并获得其Pid 使用spawn
2调用P167 页的on_exit函数去监视pid 这是可以完成任务的
  (也就是m20160627_2的monitor)


生成永不终止的进程
生成一个进程，注册 到 Name
然后生成一个进程，去监视这个Pid上面这个进程，如果挂了就重新执行这个外层的函数。。。
调用方式
75> Pid = m20160627_2:forever(pidname,fun m20160627:fun_test/0).
<0.263.0>


在模块里定义了一个函数
然后模块里另一个函数需要传参数，直接传函数名称貌似出错
Pid = m20160627_2:forever(pidname,fun m20160627:fun_test/0).
在erlang shell中去调用函数，就是使用 这个格式
？？？？？？？？？但是在spawn中传入就是直接使用函数名（包括外层是fun，里面调用spawn）

在源代码内部，传入的时候使用 fun 函数名称/元数
fun m20160627_2:funtest/1.
#Fun<m20160627_2.funtest.1>


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
更新理解：在erlang shell中 要使用模块定义好的函数作为参数就要这样调用：
fun 模块名称: 函数名称/元数    
m20160627_2:funtest(fun m20160627_2:funtest_a/0).
在模块内部调用可以直接用也可以不加模块(因为有默认的概念嘛)
funtest_b(fun m20160627_2:funtest_a/0).或者
funtest_b(fun funtest_a/0).

记住 Fun参数是传入的是函数   Func传入的是函数的名称

是不是spawn（3参数的）叫做  函数名参数
spawn（1参数的） 是传入函数
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


永不终止的进程问题也很大。。。
1传入的测试函数不输出  
2注册函数的理解。  就是一个系统上对进程Pid注册为一个固定的，可以直接对这个发送信息。


注册进程的作用就是 方便于 不仅仅是子进程的父亲可以拿到Pid
register(原子，Pid).

=============================================================
所以今早上可以先试下那个 永不终止的进程 
弄清楚各个返回的东西。。
[35797,35797,33021,26432,27515,25105,20040,65311,29616,22312,34987,26432,
 20102,19968,27425]  ？？？这是什么鬼

不管这个检视函数收到后如何，控制台都会反馈出
=ERROR REPORT==== 28-Jun-2016::10:17:57 ===
Error in process <0.468.0> with exit value: {badarg,[{erlang,list_to_atom,[a],[]},{m20160627_2,fun_test,0,[{file,"m20160627_2.erl"},{line,33}]}]}

上面的什么鬼没了。。。
好吧，也许是某个函数的返回值吧。。。反正正确写后没有了控制台都会反馈出。

==========================================
6-28
写一个分布式的，进程，万一有很多东西会出错呢。
给名称服务器发送了Key  返回了undefined 应该是内置的get函数返回的。

名称服务器里 有rpc远程调用，使用的是 kvs!  所以我认为不同erlang系统中就是不同的。。
难道kvs是整个集群里注册？？？？？？？？？？？？？？？？？？？？？ 明显不是！！
实际上是 rpc远程过程调用，实际执行的环境就是服务器
而且，弄清楚了  
‘’ 和原子的区别（这个单引号，貌似会屏蔽掉各种符号等）

比如原子遇到了特殊符号
rpc:call(gandalf@"PC-20150714XBEF",m20160628,store,[weather,fine]).
rpc:call('gandalf@PC-20150714XBEF',m20160628,store,[weather,fine]).这是对的！！！！
rpc:call('gandalf@PC-20150714XBEF','m20160628','lookup',[b]).这也是对的，因此加''上这个是没有问题的


不过整个分布式，使用的是rpc，远程过程调用，直接调用服务器端的函数，因此执行的环境也是服务器端的erlang系统

在同一个机器上运行不同的erlang系统节点时候，因为默认访问（设置的）的是同一个.erlang.cookie文件里的cookie值，因此这2个节点，默认就是设置了一样的cookie了，因此默认就是一个互联的集群了。

---------------------
上面使用了rpc:call调用而已
这次使用 global ，可以在分布式系统里注册名称。以及使用各种库

erlang:get/0  看清楚了，这是进程字典！！！不是系统字典


网络：
HUB 就是起到信号的链接传播（最多再来个信号方法，没有任何处理）
交换机（可以给力帧冲突，因此它必须知道mac 地址）


spawn(Node,fun loop2/0). %看看这个新进程的代码从哪里来的？
果然出错了，分裂到另一个节点的进程没有正确启动，。。。 这样就可以随意控制集群中的结点了（只要启动了erlang系统）
事实证明，这个代码必须在远程服务器上有，因为在我的客户端代码里 启动
spawn(Node,fun loop2/0).  需要这个fun 函数，这个函数是不会通过网络自动传输的。。。。！！！
Error in process <0.97.0> on node 'gandalf@PC-20150714XBEF' with exit value: {{badfun,#Fun<m20160628.1.40466779>},[{erlang,apply,2,[{file,"erlang.erl"},{line,2314}]}]}

还要注意，代码版本要一直，就是编译后的东西内容要一致（我试试加个空格试试，可以的）
也就是，要有相同的函数名称，调用方式等等


14.4.1 为何远程分裂后，服务器端，没有显示出信息
（bug1 是由于 fun() -> loop2() end）  忘了写loop2后面的(） 所以就没有启动loop2函数

???????????????
问题1
很奇怪，为何process called by rpc会在客户端显示，但是收到的来自服务器端的信息的确是对的？？？？
1为什么服务器端没有显示？？？？？
2为什么客户端要显示？？？？？
是不是和io:format的 显示终端标明有关系？?


--------------------------
17
套接字编程
binary_to_list(<<"abc">>)      这里实际上，二进制自动处理了内部的list为各个元素拆开的形式
 <<"hello">> 等价于 <<$h,$e,$l,$l,$o>> ,前者在语法上比后者更加便利（语法糖）

注意 B=<<>>  会被erlang理解为 =<符号


HTTP Get 协议的标示符号
就是给一个端口发送一个TCP数据包
"GET / HTTP/1.0\r\n\r\n"

string:tokens(binary_to_list(Bin),"\r\n"). 应该是分段显示了吧 正则匹配，然后返回[] 

erlang里有个约定，每个逻辑请求（因为要分清楚 每次请求，因为一次请求可能返回好多次结果 ）
因此{packet,N}  用于表示一次逻辑请求的长度（而不是网络中实际长度），而且，客户端和服务器使用的packet的参数必须一致，否则会出错。
相比 HTTP或者XML 这些基于文本的方法， 打包和编码的erlang数据更加便利


不同于进程之间的直接发送消息，（直接给此Pid发送就可以了）
套接字编程发送信息需要本地的Socket和远端Socket，使用的时候只需要使用本地的Socket就好了


？？？？？？？？？？？？？？
问题2    解决了。
那个发送Socket Http get 的函数
接受Socket 消息的方式 很奇怪
%这个很神奇的函数被调用。 也就是 socket属于erlang 的socket类型。erlang系统是外层，在erlang里使用socket，会被转化为对进程发送消息{tcp,Socket,Bin} 那岂不是可以 干扰了。
erlang套接字默认是主动模式，因此可以将受到的消息转发到这个套接字所在的进程上
{active, true}
创建某个套接字的进程称为该套接字的控制进程，所有来自套接字的消息都会被发送到控制进程！！！！控制进程挂了，套接字也会关闭。也可以将某个套接字的所属控制进程进行修改，这个应该很有用了，gen_tcp:controlling_process( Socket,NewPid) 





receive_data(Socket,SoFar) ->  
receive                 %这个函数怎么能收到消息呢？
	{tcp,Socket,Bin} ->
		receive_data(Socket,[Bin|SoFar]); %也就是每个元素都是一个二进制类型
	{tcp_closed,Socket} ->
		list_to_binary(lists:reverse(SoFar))  %为何要翻转，因为受到的数据是一个一个分片的
end.



？？？？？？？？？？？？？？？
问题3   ok  但是在网上查不到
string2value 
里面的erl_scan 都是那些模块？使用
module_loaded(erl_scan). true 说明已经加载了 查不到。
但是能搜索到erl_scan这个模块已经加载了




问题4
Listen里设置这个{packet,4} 4个字节的函数 （意思就是我发送TCP小于4个字节就不去处理？）的含义？
我设置40编译都过不了。。  这个只能是1,2,4

数据连包问题  由于时间极端，因此可能把几次的数据 当做一次的？
对于第二种方式（主动模式），缓存区有多少数据，都会全部以消息{tcp, Socket, Data} 投递给线程。

对于数据粘包问题
raw | 0 
没有封包，即不管数据包头，而是根据Length参数(非主动模式)接收数据。 

1 | 2 | 4 
每个逻辑请求包头，其计数的字节长度，分别是1,2,4个字节（2,4以大端字节序，无符号表示），当设置了此参数时，接收到数据后将自动剥离对应长度的头部，只保留Body。




大端模式，数据的高字节（逻辑含义高）在内存低地址。这样存储有点像把数据当做字节流处理
小端模式比如 4字节的小端模式
0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000
0000440: b484 6c4e 004e ed00 0000 0000 0100 0000
则是4e 6c 84 e6                   
X86结构是小端模式

Java是平台无关的，默认是大端。在网络上传输数据普遍采用的都是大端(网络，字节流大端模式应该更方便些)

