pwd().
cd("C:\Users\Administrator\Desktop\erlcoding").

列表推导[||生成器或者位串生成器或者过滤器，生成器或者位串生成器或者过滤器]

生成器 x-<x  相当于列表提取

位串 x<=x  相当于位串提取

Bin2 = <<A, B, C:16>>   这里C指定了位数为32位
产生的二进制数据大小为4，binary_to_list(Bin2)计算结果是 [1, 17, 0, 42]。这里C使用了尺寸表达式（size expression）,指定了C这个段在二进制数据中占用16位，也就是两个单位长度。 


<<A, B, C:16>>  结果是  前面是空，后面是16
<<1,17,0,42>>

列表推导里的生成器 也起到一定的过滤器作用

[]++[]++[]
这样就可以合并列表 ，但是一般不认为是良好的编程实践做法（当list很短的时候可以用，效率低下）
X--Y 就是把Y从X中移除  比如列表L--[元素H]
比如要翻转，使用lists:reverse效率很高的!!


[H|T] 这个也可以合并列表


==    =：= 逻辑判断的等号
      N == 0  这个等号也是有的 


lists:seq(1,N)

A+B+C =<N   等于小于   小于等于<=( 因为这个有位串提取的含义)因此不用。
大于等于   >=没有问题   等于大于有问题
也就是 小于等于不能用  等于大于不能用             <=   => 这2个不能用
也就是 箭头针不偏向= 不行
=:=  逻辑等于


递归实现 全排列
perms([]) -> [[]]; %不export只能内部调用就OK
perms(L) -> [[H|T]|| H<- L,T<- perms(L--[H])].  我第一次在[H]出错了
            而且这里不好理解，[H|T] 最后变成了完整的一个字符串 
                              因为最后一次递归调用后，T开始提取了 提取一个元素，然后上一次
递归理解，perms返回的是当前字符串的全排列数组[abc,acb,bac,bca,cab,cba] 因此4长度时候先拿出一个列表头，然后玩剩余的全排列拼装到头上
也就是这个        [H|T]    也算是拼装！！！！！！


匹配=  的时候注意 匹配两边需要使用空格


关卡关键字 when
关卡的序列，有一个true 就是true， 中间用；分割  类比函数的；        ；是或的意思
关卡  由一系列的关卡表达式组成  使用，分割      全部都true才是true  ，是并且的意思

关卡不能调用用户定义的函数，因为要确保它们没有副作用并能正常结束。
有关卡判断函数


短路布尔表达式 orelse 不会判断后面不需要判断的表达式了


is_binary(<<"1,2,3">>).


貌似 if  和 case of 可以只用一个

    if
        N == 0 -> 1;
        N > 0 -> N * factorial(N - 1)
    end.

    case N of
        0 -> 1;
        N when N > 0 ->
            N * factorial(N - 1)
    end.

个人感觉if 更舒服一点吧（其实还不太一样，采用逻辑最舒服的）
if 
    guard1 -> 表达式1;
    guard2 -> 表达式2;
    ...

case 表达式 of  这个先执行表达式 然后再去匹配
    pattern1 [guard1] ->表达式1;
    ...

所有表达式都应该有值，因此if就算不匹配最后也要加上true 
    
在单个函数里语句应该用,吧   .是权力最大的   ,（比如匹配函数中内顺序执行，错一步都不行所以用，）  ;(是匹配选择，或者if case选择 之前 哪一个都行，所以用；)


===========================================
今日把第4章节的练习题做完

建议将手册中所有内置函数打印出来，没事就看。。。

吃饭时候总结下，今天看到的众多函数




