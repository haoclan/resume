pwd().
cd("C:/Users/Administrator/Desktop/erlcoding").


列表推导[||生成器或者位串生成器或者过滤器，生成器或者位串生成器或者过滤器]

生成器 x<-L  相当于列表提取

位串 x<=bitstring  相当于位串提取

Bin2 = <<A, B, C:16>>   这里C指定了位数为16位
产生的二进制数据大小为4，binary_to_list(Bin2)计算结果是 [1, 17, 0, 42]。这里C使用了尺寸表达式（size expression）,指定了C这个段在二进制数据中占用16位，也就是两个单位长度。 


<<A, B, C:16>>  结果是  前面是空，后面是16
<<1,17,0,42>>

列表推导里的生成器 也起到一定的过滤器作用

[]++[]++[]
这样就可以合并列表 ，但是一般不认为是良好的编程实践做法（当list很短的时候可以用，效率低下）
X--Y 就是把Y从X中移除  比如列表L--[元素H]
比如要翻转，使用lists:reverse效率很高的!!


[H|T] 这个也可以合并列表


=:=  这个是绝对等号
      N == 0  这是数值等号，


lists:seq(1,N) 生成从1到10的序列


A+B+C =<N   等于小于   小于等于<=( 因为这个有位串提取的含义)因此不用。
大于等于   >=没有问题   等于大于有问题 =>(这个是映射组的设置键值对)
也就是 箭头针不偏向= 不行



递归实现 全排列（！！！！！！！！！）,厉害在2个生成器，第二个生成器的东西依赖于第一个生成，（第一个生成器有遍历的东西，因此第2个生成器也会产生不同的东西）
perms([]) -> [[]]; 
perms(L) -> [[H|T]|| H<- L,T<- perms(L--[H])].  我第一次在[H]出错了
            而且这里不好理解，[H|T] 最后变成了完整的一个字符串 
                              因为最后一次递归调用后，T开始提取了 提取一个元素，然后上一次
递归理解，perms返回的是当前字符串的全排列数组[abc,acb,bac,bca,cab,cba] 因此4长度时候先拿出一个列表头，然后玩剩余的全排列拼装到头上
也就是这个        [H|T]    也算是拼装！！！！！！





匹配=  的时候注意 匹配两边需要使用空格


关卡关键字 when
关卡的序列，有一个true 就是true， 中间用；分割  类比函数的；        ；是或的意思
关卡  由一系列的关卡表达式组成  使用，分割      全部都true才是true  ，是并且的意思

关卡不能调用用户定义的函数，因为要确保它们没有副作用并能正常结束。 （关卡中不能使用匹配）
有关卡判断函数


短路布尔表达式 orelse 不会判断后面不需要判断的表达式了


is_binary(<<"1,2,3">>).


貌似 if  和 case of 可以只用一个（case多一个匹配的过程。所以if 中有 true的关卡）

    if
        N == 0 -> 1;
        N > 0 -> N * factorial(N - 1)
    end.

    case N of
        0 -> 1;
        N when N > 0 ->
            N * factorial(N - 1)
    end.

个人感觉if 更舒服一点吧（其实还不太一样，采用逻辑最舒服的）
if 
    guard1 -> 表达式1;
    guard2 -> 表达式2;
    ...

case 表达式 of  这个先执行表达式 然后再去匹配
    pattern1 [guard1] ->表达式1;
    ...

所有表达式都应该有值，因此if就算不匹配最后也要加上true 
    
在单个函数里语句应该用,吧   .是权力最大的   ,（比如匹配函数中内顺序执行，错一步都不行所以用，）  ;(是匹配选择，或者if case选择 之前 哪一个都行，所以用；)


===========================================
建议将手册中所有内置函数打印出来，没事就看。。。
吃饭时候总结下，今天看到的众多函数


今日把第4章节的练习题做完

2 元组到list  如何去匹配 未知的元组里的东西。
使用 element(N,X) 第N个，在X元组里
size(X) 元组的大小 所以使用递归，因为元组没法拆解，因此只能每次传递


now() GMT0点开始 1970 
date()
time()

3 编写以 函数为参数的 函数， 执行这个函数后，输出当前时间结果。
如果调用的时候直接使用F(3) 相当于 将这个函数执行的结果当做参数输入了。
===============================================================
6.21

if 里 关卡 判断不能直接调用函数
因此更适用于case

    case F(H) of
        true -> filter2(F,T,[H|R]);  感觉这个东西是不是和case中的 语法矛盾了
        flase -> filter2(F,T,R)  
    end    
case如果所有的模式都不匹配就会发生错误（因此它比if更容易发生错误，if里有个 true万能的匹配，case里没有）        

    if
        关卡1 ->
        true 关卡->
    end


有关卡判断函数 和关卡内置函数！！！！！！！！！！！！！
关卡里不能随便调用函数值，也不能使用模式匹配。
所以这个是错误的，因为不嫩刚在应该使用关卡的地方随意地使用匹配。
start(T) ->
    if
        {ok,A} =T -> A;
        true -> T.


    

感觉这个题还有其他的方法，比如 来个一次一行式语句？等

关卡，可以在函数定义的头部使用关卡（通过when关键字的引入），也可以在任何支持表达式的地方使用它们。

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
终于找到了case 和if 的本质区别  case各个条件是匹配，而if的各个条件是关卡。

case 一个要执行的表达式 of
然后就是基本匹配可以带关卡  因此在此 true也就是普通的匹配了

但是在if中
各个选项只是一个可以返回真假的关卡类型的东西，执行到第一个为真的就返回了。因此这里true“自然而然”地成为一个“特殊”的


归集器？？？？？？？？？？？？？ 实际上就是一种模式？多参数保存住，然后使用case 可以遍历一次就OK

使用归集器的方法 
列表推导式
[||]


记录的定义（记录的定义既可以放在原代码里，也可以放在.hrl文件里， .hrl文件包含是唯一能确保多个Erlang模块共享记录定义的方式！！！！）  
.hrl   -record(todo,{}).
#todo{}
X1=#todo{key=value,key=value,...}
X2=X1#todo{} 在X1基础上修改


#todo{key=Value1,key=Value2,...} = X2  用于提取记录 

X2#todo.key  来得到变量中单个的值
注意这个提取，不是使用X2.key  而是  变量#基于解释的记录.值
因为本质上X2是元组，因此需要  X2#todo.key
在传参数匹配的时候
#todo{status = S,who = W } = R 
???看看能不能 不要右边这匹配的东西的写法  
能！完全可以不要等号右边这些，有这些的意义就是方便之后直接使用元组的东西。（正确理解的模式，就是因为=的值本来就是右边的值，因此参数匹配的时候就自然而然先把值赋值给了等号右边的这个东西）




映射组中，有没有这个键，直接在 函数的参数匹配中就完成了（因为erlang匹配不上的话直接就不调用此函数了。）
f(bulabula,K确定了,#{K := Value } = X) 
f(bulabula,K确定了,X)
也可以使用maps:is_key(Key,Map) 这个函数去判断


关卡 判断是否是此要求的记录
f(X) when is_record(X,todo)   这里不加#todo  类似于 函数调用与函数

io:format的 ~p选项输出映射组 用io:read 或者file:consult读取

JSON 
{键值对，键值对}   也有数组的类型 数组可以是一个值

映射组于JSON相互转换
maps:to_json(Map)->Bin
maps:from_json(Bin)->Map


==  比如float和int那么，==操作会首先把两个数字转换成相同的相同类型
1==1.0 
=：= 精确等于 不会自动转换的


元组的正确使用方法，是给一个键快速得到它的值 ，也是通过匹配的方式获得的
f(bulabula,K确定了,#{K := Value } = X) 


start(T) when is_tuple(T) and element(1,T)== ok ->
    hello.

start(T) when {ok,_} = T ->        关卡里不能乱用模式匹配！
    hello.


===========================================
6.21
问题1：math_functions 文件里
在同一个模块里，如果把一个函数当做参数 传入并调用
%这里有个问题！！！！！！！
%filter(L) -> %返回一个{Even,Odd}
%   {filter(even,L),filter(odd,L)}. %问题1！！！！！！！！！！！！！！！ 想传入 本模块中函数为参数
答案是： fun 函数名/元数


问题2：
将json转变为映射组 的函数没有
maps:from_json()




问题4 
P75 2. 
如何生成2条错误消息？的意思？
一个友好的返回给用于，一个写入到一个错误的文件



问题3：
自己解决吧
让P63 的输出的映射组变为 #{字符1=>1,字符2=>3}. 我使用io:format()
shell竟然说我参数个数不对
我使用函数解决了，貌似


感觉对应关系是list “”改成 list后
试一下。。。。
也OK的

===========================
6.22
map的操作 R17版本里很有限 R18版本里比较好了
在map_search_pred.erl

位处理
<<16#1235425:32>>

拼接二进制 <<,>> 里面各个格式都是可以的

<< <<1:8>>:1/binary>>.   当个数超过了本来有的数据它就报错了

bittext
====================================================
6-23

87页 第4题。bit的翻转。。。。
我解决了啊： [X || <<X:1>> <= Binary]   位提取，每次只提取1位！  然后成了list
list_to_binary(lists:reverse(List)).


块表达式的用处 表达式序列 区别 ok了（很明显，参数的时候需要，表达式序列和，混乱了）
begin expr1,expr2,...expr end   它的值也是最后一个
expr1,expr2,...expr 表达式序列   它的值是最后一个
[  || X <- L]
[1,2,3,X||X <- L].
[begin 1,2,3,X end||X <- L].  类似于有个()让其最后返回一个值吧。而且，明显表达式序列不能用于多参数传递的时候，因为，分不清楚了


P110
使用 递归  配合 when  （他人的设计比较巧妙）

%但是这个加入的list方法。。。有层次关系了！！！！！！！！！！！


抽象以下问题 （该看看别人的代码了。。然后总结）
8章节的课后题，看看人家怎么做的

1 这个方法是找到最多的模块的次数 
差距在他人一次性处理复杂的匹配，而不是像我一次一次弄简单了才继续!!!!!!
get_info([ {模块，文件} ]，临时最大值)
在这个函数里直接处理 一个模块信息的匹配，然后递归调用get_info就ok

2 哪个函数名最常见
get_info([ {模块，文件} ] , 临时的键值对X)
在里面提取出 L[]里面都是{函数名称，参数值}


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
get_info(T, count_function(L, X));  这种  键值对在不同函数递归中调用。。。 是合理的！！！！
因为在最底层的直接递归完，然后函数返回  上一层使用的键值对已经变为了底层函数的返回值.
所以最终2层递归后 返回的是  键值对
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


count_function(L{函数名称，参数值}, 键值对) 

然后所有的处理都是基于 这个键值对了

找只出现一个次的。 先获得所有的键，然后通过键再去取值
L = maps:keys(X)
lists:filter( fun(E) -> {ok, Value} = maps:find(E, X),Value == 1 end, L). 人家一句话就过滤剩下值为1 的东西了    
！！！！！！！他用的是lists:fileter 我用的是maps:fold ,貌似我的更高端。。。。(见我的m1.erl)


找最常见的函数名
for(所有键值对中的键list,X,保存键,保存最大值)  for是自己定义的函数，递归调用


---------------
lists:foreach(Fun,List) 
列表 List 里的每一个元素按从左向右的顺序被函数 Fun 调用，最后返回一个 ok。
问题，这个到底怎么用。。。。计算的结果如何拿到？因为没有规定 Fun的参数个数，因此功能能强大一些。
返回值肯定不是 这个lists：foreach函数。 应该是在Fun中做一些保存结果的事情啦，比如保存文件，或者调用其他函数，这样的Fun应该不会触发 零参数的东西吧。 因为这个Fun的正确参数已经是元素了，不是列表，因此不会涉及递归什么的了

下面这个函数可以输出结果了，相对比较更容易使用了。

lists:foldl/3  列表里的元素递归调用函数（还有个lists:foldr 是从右向左地调用）
列表 List 里的每一个元素按从左向右的顺序，依次跟一个累积器（accumulator）参数 Acc0 作为 Fun 的参数被调用执行，并返回一个新的累积器 Acc1 跟列表的下一个元素调用，直到调用完列表里的所有元素，最终返回累积器 Acc 的结果值。

maps:fold/3
对映射组里的键值递归遍历执行一系列操作


Unity3D 语言C#

SLG 模拟类游戏
ACT 动作
RTS 实时策略
FPS (First-person shooting game）
==================================================================
6-24
定时器的实现 是通过带超时的接受语句

尾递归问题我的程序 processes 

erlang  模式匹配 有顺序吗？？？？  有的吧。
如果有顺序的话P154 是不是没用了   不是，一个receive就会有一个邮箱为空挂起的机制


邮箱为空就挂起的机制，可以通过 after 0  -> 来打破


-----------------------------------------------------------------
receive
end

也是表达式，因此必须有返回值，当查看邮箱里的一封消息的时候，先进行匹配，如果匹配了就有返回值了，如果不匹配，将这条消息加入一个队列，然后再继续读取下一条，直到有返回值

如果邮箱为空，这回挂起，直到有新的消息来。
！！！！一旦某个消息匹配成功了或者定时器被触发了，保存队列里的所有消息就复活了！！！！！！！！！！！！！！！！！！！！！

如果设置了定时器，则会清除它？？它是谁？P156，先忽略这句话。。
！！！！一旦定时器到期了，会把保存的消息重新放回。个人认为，有了返回值就重新放回（放回有啥意义？2版本代码共存时候用？    ）


注册，register(原子，一个函数返回的pid)   这样的话 "系统里" 
这个pid，因此必须使用spawn()，生成新的进程，而不是函数的一次执行。
 
果然是的，直接在erlang shell里都可以发送消息 
人家都说了是注册进程，所以不能随便绑定。（注册进程的话，进程消亡这个绑定自动就结束了）

  
'Down'
Down
一样！！！因为 'down' == down. 是 true


{'EXIT',Pid,Why} 错误信号
{'DOWN',Ref,process,Pid,Why} 这是发给监视者的消息

169 
after 
    infinity的作用????
http://diaocow.iteye.com/blog/1757382 
after infinity： 
表示若mail-box中没有消息能够pattern match ，则一直阻塞，直到有一条消息能够pattern match（这种情况等价于不写after，是receive代码块的默认操作) 



client() ->  %%%%这样的函数直接运行 erlang shell 就死了。。。因为有接收函数，一般要新建一个进程
    receive
        X -> 
            list_to_atom(X)
    end.
erlang shell的死亡原因是 主线程被阻塞了，因此主线程什么都不干了。。。。。


